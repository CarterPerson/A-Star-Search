### Carter Person, CS76 20F, PA2

## A* function
For my A* function, I stored the frontier in a heap which was organized by the A* scores for the different nodes being stored. As long as the heap is not empty, I pop the node in queue with the lowest score, check if that node represents the goal state. If it does, I get the path and the total length of the path and return the solution object. Otherwise, it calls the successor function that the search problem has, and then iterates through all of the options. The objects returned from the successor function are expected to follow a specific format. The 0th index is expected to be a tuple representing the state, and the 1st index is expected to be the cost to transition to that state. For each option, it checks whether or not that state has been visited before in a dictionary, and if it has, if it has been visited before at a lower cost. If the state has not been visited before or if the state has been visited before, but at a higher cost the last time it was visited,  the function will add that to the heap of nodes to visit and also add that state and it's cost to the dictionary. It then goes back and takes out the one with the lowest score from the heap and continues like this.

## Multi-robot pathing
The key to my multi-robot pathing solution lies in the get_successors function. The state that I decided to use for multi-robot pathing is the first number being the next robot to move, followed by x and y pairs that represent the locations of the robots. In my get_successors function, I read the first number to see which robot is moving, and then create an empty "returner" list as well as a "baseadder" list and append the number that represents the next robot to "baseadder". I use a value "numrobots" to determine when I need to return back to the first robot moving again, which is calculated by taking the length of the goal states and dividing it by 2. For each potential move, I create a copy of baseadder and then add in the state that follows each of the different actions. I check and make sure that the move is ok by making sure that the tile im moving the robot to is not another robot and is not a wall, and then I turn that state into a tuple and proceed to add it, along with that moves cost, as a tuple to returner. This creates a list of all of the possible states and the cost of transition in the returner object and can pass it on to the A* function.


I use the manhattan heuristic here, as I feel like it is a good representation of the distance to the goal-state that will usually have relatively low error.


I also added in another file to account for the bonus question of having time be a factor. This is an extremely similar problem as the normal multi-robot pathing problem, except that for the costs that I pass along with the state are different. I made the cost of waiting be 1, and the cost of moving be 10. This successfully reduces the amount of moves that it takes to solve the problem. I don't have a separate testing file for this, but it would be essentially a copy paste of the normal one, with just the name of the search type changed.


## Sensorless robot pathing
For my sensorless robot, I read in a maze, and then placed a robot at all locations in that maze that are not walls. I used a similar heuristic as with my normal multi-robot pathing, except for this one I took an average of the manhattan heuristics for each robot. This heuristic favors moves that, on average, move all possible robot locations closer to the goal-state, which I felt would be a good model to run with. In my get_successors function, I added the options for moving in each of the cardinal directions. In each of these, I went through every possible robot location in the state that was passed in, and added its new location after moving to a set. After going through all of the possible robot locations from the state that was passed in, I then had a complete set of all possible locations where the robot could be. I chose to use a set because if the action were to cause one possible location to stay still (if it were going against a wall) and another robot to move on top of it, it would then only count that as one possible location and eliminate any duplicates. This was effective in decreasing the number of possible locations where the robot could be in the next state. I then iterated through the set and added everything into a state object that represented all the possible locations, and then passed this state object with a cost value of 1 into a returner list, which I returned after adding the new states from moving east, west, north, or south. I ommitted the action of the robot waiting because, in this situation, there is no point in the robot waiting.



#### note: for the testing files, I have commented out all path animating. If you would like to see it, simply uncomment the lines.

#### note: I have included a short MATLAB script I used to generate some random mazes
